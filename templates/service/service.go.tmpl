package {{ .CurrentPackage }}

import (
	"context"
	"log"
	"{{ .ModuleName }}/api/gen"
{{- if eq (index .ServiceDatabaseMap .CurrentServiceName).Type "postgres" }}
	"{{ .ModuleName }}/db/postgres/dbgen"
{{- end }}
)

type Create{{ .CurrentModelName | singularize | title }}Params struct {
	{{- range $propertyName, $property := .CurrentModel.Properties }}
	{{ $propertyName | camelcase }} {{- if .NotNull }}{{ .Type }}{{- else }}*{{ .Type }}{{- end }}
	{{- end }}
	{{- if eq .CurrentModel.Type "user" }}
		{{- range $propertyName, $property := userProperties }}
	{{ $propertyName | camelcase }} {{- if .NotNull }} {{ .Type }}{{- else }}*{{ .Type }}{{- end }}
		{{- end }}
	{{- end }}
}

type Update{{ .CurrentModelName | singularize | title }}Params struct {
	ID int64
	{{- range $propertyName, $property := .CurrentModel.Properties }}
	{{ $propertyName | camelcase }} {{- if .NotNull }} {{ .Type }}{{- else }}*{{ .Type }}{{- end }}
	{{- end }}
	{{- if eq .CurrentModel.Type "user" }}
		{{- range $propertyName, $property := userProperties }}
	{{ $propertyName | camelcase }} {{- if .NotNull }} {{ .Type }}{{- else }}*{{ .Type }}{{- end }}
		{{- end }}
	{{- end }}
}

type service struct {
	repo *Repo
}

func NewService(
	repo *Repo,
) *service {
	return &service{
		repo: repo,
	}
}

// Support for basic CRUDs use cases
func (s *service) Create{{ .CurrentModelName | singularize | title }}(ctx context.Context, params *gen.Create{{ .CurrentModelName | singularize | title }}) (*gen.Create{{ .CurrentModelName | singularize | title }}ResponseBody, error) {
	/* res, err := s.repo.Create(
		ctx,
	{{- range $propertyName, $property := .CurrentModel.Properties }}
		params.{{ $propertyName | camelcase }},
	{{- end }}
	{{- if eq .CurrentModel.Type "user" }}
		{{- range $propertyName, $property := userProperties }}
		params.{{ $propertyName | camelcase }},
		{{- end }}
	{{- end }}
	)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &gen.Create{{ .CurrentModelName | singularize | title }}ResponseBody{
		// TODO: Implement this
	}, nil */

	return nil, nil
}

func (s *service) Update{{ .CurrentModelName | singularize | title }}(ctx context.Context, id int64, params *gen.Update{{ .CurrentModelName | singularize | title }}) (*gen.Update{{ .CurrentModelName | singularize | title }}ResponseBody, error) {
	/* res, err := s.repo.Update(
		ctx,
		id,
	{{- range $propertyName, $property := .CurrentModel.Properties }}
		params.{{ $propertyName | camelcase }},
	{{- end }}
	{{- if eq .CurrentModel.Type "user" }}
		{{- range $propertyName, $property := userProperties }}
		params.{{ $propertyName | camelcase }},
		{{- end }}
	{{- end }}
	)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &gen.Update{{ .CurrentModelName | singularize | title }}ResponseBody{
		// TODO: Implement this
	}, nil */

	return nil, nil
}

// Support for extra implementations
{{- range $methodName, $method := .CurrentService.Methods }}
func (s *service) {{ $methodName }}(ctx context.Context,{{- range .Arguments }}{{ .Name }} {{ .Type }}, {{- end }}) {{- if gt (len .Returns) 0 }}({{- range .Returns }}{{ . }} ,{{- end }}error){{- else }}error{{- end }} {
	
	return nil, nil
}
{{- end }}